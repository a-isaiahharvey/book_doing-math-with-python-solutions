#+title: Solutions
#+author: Allister Isaiah Harvey
#+date: 17-11-2023
#+property: header-args:python :python python3
#+startup: showeverything
#+options: toc:3

* Requirements

These are the packages that are required to be installed before running the source code

#+begin_src txt :tangle requirements.txt
matplotlib
pyowm
#+end_src

* Chapter 1

** Challenge 1 - Even-Odd Vending Machine

Try writing an “even-odd vending machine,” which will take a number as input and do two things:

1. Print whether the number is even or odd.

2. Display the number followed by the next 9 even or odd numbers.

If the input is 2, the program should print even and then print 2, 4, 6, 8, 10, 12, 14, 16, 18, 20. Similarly, if the input is 1, the program should print odd and then print 1, 3, 5, 7, 9, 11, 13, 15, 17, 19. 

Your program should use the is_integer() method to display an error message if the input is a number with significant digits beyond the decimal point.

#+begin_src python :tangle 1_1.py
  def even_odd(num):
      if num % 2 == 0:
          print("even")
      else:
          print("odd")
      for i in range(0, 20, 2):
          print(num + i)

  if __name__ == '__main__':
      even_odd(2)
#+end_src

** Challenge 2 - Enhanced Multiplication Table Generator

Our multiplication table generator is cool, but it prints only the first 10 multiples. Enhance the generator so that the user can specify both the number and up to which multiple. For example, I should be able to input that I want to see a table listing the first 15 multiples of 9.

#+begin_src python :tangle 1_2.py
def enhanced_multi_table(a, end_mult):
    for i in range(1, int(end_mult) + 1):
        print('{0} x {1} = {2}'.format(a, i, a * i))


if __name__ == '__main__':
    a = input('Enter a number: ')
    b = input('Enter the last multiple: ')
    enhanced_multi_table(float(a), b)
#+end_src

** Challenge 3 - Enhanced Unit Converter

The unit conversion program we wrote in this chapter is limited to conversions between kilometers and miles. Try extending the program to convert between units of mass (such as kilograms and pounds) and between units of temperature (such as Celsius and Fahrenheit).

#+begin_src python :tangle 1_3.py
  def print_menu():
      print('1. Kilometers to Miles')
      print('2. Miles to Kilometers')
      print('3. Celsius to Fahrenheit')
      print('4. Fahrenheit to Celsius')
      print('5. Kilograms to Pounds')
      print('6. Pounds to Kilograms')


  def km_mi():
      km = float(input('Enter distance in kilometers: '))
      mi = km / 1.609

      print('Distance in miles: {0}'.format(mi))


  def mi_km():
      mi = float(input('Enter distance in miles: '))
      km = mi * 1.609

      print('Distance in kilometers: {0}'.format(km))


  def c_f():
      c = float(input('Enter temperature in Celsius: '))
      f = c * (9 / 5) + 32

      print('Temperature in Fahrenheit: {0}'.format(f))


  def f_c():
      f = float(input('Enter temperature in Fahrenheit: '))
      c = (f - 32) * (5 / 9)

      print('Temperature in Celsius: {0}'.format(c))


  def kg_lbs():
      kg = float(input('Enter mass in kilograms: '))
      lbs = kg * 2.2046

      print('Mass in pounds: {0}'.format(lbs))


  def lbs_kg():
      lbs = float(input('Enter mass in pounds: '))
      kg = lbs / 2.2046

      print('Mass in kilograms: {0}'.format(kg))


  if __name__ == '__main__':
      print_menu()

      choice = input('Which conversion would you like to do?: ')
      if choice == '1':
          km_mi()
      elif choice == '2':
          mi_km()
      elif choice == '3':
          c_f()
      elif choice == '4':
          f_c()
      elif choice == '5':
          kg_lbs()
      elif choice == '6':
          lbs_kg()
#+end_src

** Challenge 4 - Fraction Calculator

Write a calculator that can perform the basic mathematical operations on two fractions. It should ask the user for two fractions and the operations the user user wants to carry out. As a head start, here's how you can write the program with only the addition operation:

#+begin_src python :tangle 1_4.py
  from fractions import Fraction


  def add(a, b):
      print('{0} + {1} = {2}'.format(a, b, a + b))


  def subtract(a, b):
      print('{0} - {1} = {2}'.format(a, b, a - b))


  def multiply(a, b):
      print('{0} * {1} = {2}'.format(a, b, a * b))


  def divide(a, b):
      print('{0} / {1} = {2}'.format(a, b, a / b))


  if __name__ == '__main__':

      a = Fraction(input('Enter first fraction: '))

      b = Fraction(input('Enter second fraction: '))
      op = str.lower(
          input('Operation to perform - Add, Subtract, Mulitply, Divide: '))
      if op == 'add':
          add(a, b)
      elif op == 'subtract':
          subtract(a, b)
      elif op == 'multiply':
          multiply(a, b)
      elif op == 'divide':
          divide(a, b)
      else:
          print('Input a valid operation')
#+end_src

** Challenge 5 - Give Exit Power to the User

All the programs we have written so far work only for one iteration of input and output. For example, consider the program to print the multiplication table: the user executes the program and enters a number; then the program prints the multiplication table and exits. If the user wanted to print the multiplication table of another number, the program would have to be rerun.
It would be more convenient if the user could choose whether to exit or continue using the program. The key to writing such programs is to set up an infinite  loop, or a loop that doesn’t exit unless explicitly asked to do so. Below, you can see an example of the layout for such a program:

#+begin_src python
  '''
  Run until exit layout
  '''
  def fun():
      print('I am in an endless loop')

  if __name__ == '__main__':
      while True:
          fun()
          answer = input('Do you want to exit? (y) for yes ')
          if answer == 'y':
              break
#+end_src

We define an infinite loop using while True atu. A while loop continues to execute unless the condition evaluates to False. Because we chose the loop’s condition to be the constant value True, it will keep running forever unless we interrupt it somehow. Inside the loop, we call the function fun(), which prints the string I am in an endless loop. Atv, the user is asked “Do you want to exit?” If the user enters y as the input, the program exits out of the loop using the break statement (break exits out of the innermost loop without executing any other statement in that loop). If the user enters any other input (or none at all, just pressing ENTER), the while loop continues execution—that is, it prints the string again and continues doing so until the user wishes to exit. Here is a sample run of the program:

#+begin_example
I am in an endless loop
Do you want to exit? (y) for yes n 
I am in an endless loop
Do you want to exit? (y) for yes n 
I am in an endless loop
Do you want to exit? (y) for yes n 
I am in an endless loop
Do you want to exit? (y) for yes y
#+end_example

Based on this example, let’s rewrite the multiplication table generator so that it keeps going until the user wants to exit. The new version of the program is shown below:

#+begin_src python
  '''
  Multiplication table printer with
  exit power to the user
  '''

  def multi_table(a):

      for i in range(1, 11):
          print('{0} x {1} = {2}'.format(a, i, a*i))

  if __name__ == '__main__':

      while True:
          a = input('Enter a number: ')
          multi_table(float(a))

          answer = input('Do you want to exit? (y) for yes ')
          if answer == 'y':
              break
#+end_src

If you compare this program to the one we wrote earlier, you’ll see that the only change is the addition of the while loop, which includes the prompt asking the user to input a number and the call to the multi_table() function.

When you run the program, the program will ask for a number and print its multiplication table, as before. However, it will also subsequently ask whether the user wants to exit the program. If the user doesn’t want to exit, the program will be ready to print the table for another number. Here is a sample run:

#+begin_example
Enter a number: 2
2.000000 x 1.000000 = 2.000000 
2.000000 x 2.000000 = 4.000000 
2.000000 x 3.000000 = 6.000000 
2.000000 x 4.000000 = 8.000000
2.000000 x 5.000000 = 10.000000 
2.000000 x 6.000000 = 12.000000 
2.000000 x 7.000000 = 14.000000 
2.000000 x 8.000000 = 16.000000 
2.000000 x 9.000000 = 18.000000 
2.000000 x 10.000000 = 20.000000

Do you want to exit? (y) for yes n
Enter a number:
#+end_example

Try rewriting some of the other programs in this chapter so that they continue executing until asked by the user to exit.

#+begin_src python :tangle 1_5_1.py
  def even_odd(num):
        if num % 2 == 0:
            print("even")
        else:
            print("odd")
        for i in range(0, 20, 2):
            print(num + i)

  if __name__ == '__main__':

      while True:
          even_odd(2)
          answer = input('Do you want to exit? (y) for yes ')
          if answer == 'y':
              break
#+end_src

#+begin_src python :tangle 1_5_2.py
  def print_menu():
      print('1. Kilometers to Miles')
      print('2. Miles to Kilometers')
      print('3. Celsius to Fahrenheit')
      print('4. Fahrenheit to Celsius')
      print('5. Kilograms to Pounds')
      print('6. Pounds to Kilograms')


  def km_mi():
      km = float(input('Enter distance in kilometers: '))
      mi = km / 1.609

      print('Distance in miles: {0}'.format(mi))


  def mi_km():
      mi = float(input('Enter distance in miles: '))
      km = mi * 1.609

      print('Distance in kilometers: {0}'.format(km))


  def c_f():
      c = float(input('Enter temperature in Celsius: '))
      f = c * (9 / 5) + 32

      print('Temperature in Fahrenheit: {0}'.format(f))


  def f_c():
      f = float(input('Enter temperature in Fahrenheit: '))
      c = (f - 32) * (5 / 9)

      print('Temperature in Celsius: {0}'.format(c))


  def kg_lbs():
      kg = float(input('Enter mass in kilograms: '))
      lbs = kg * 2.2046

      print('Mass in pounds: {0}'.format(lbs))


  def lbs_kg():
      lbs = float(input('Enter mass in pounds: '))
      kg = lbs / 2.2046

      print('Mass in kilograms: {0}'.format(kg))


  if __name__ == '__main__':
    
      while True:
          print_menu()

          choice = input('Which conversion would you like to do?: ')
          if choice == '1':
              km_mi()
          elif choice == '2':
              mi_km()
          elif choice == '3':
              c_f()
          elif choice == '4':
              f_c()
          elif choice == '5':
              kg_lbs()
          elif choice == '6':
              lbs_kg()

          answer = input('Do you want to exit? (y) for yes ')
          if answer == 'y':
              break
#+end_src

#+begin_src python :tangle 1_5_3.py
  from fractions import Fraction


  def add(a, b):
      print('{0} + {1} = {2}'.format(a, b, a + b))


  def subtract(a, b):
      print('{0} - {1} = {2}'.format(a, b, a - b))


  def multiply(a, b):
      print('{0} * {1} = {2}'.format(a, b, a * b))


  def divide(a, b):
      print('{0} / {1} = {2}'.format(a, b, a / b))


  if __name__ == '__main__':

      while True:
          a = Fraction(input('Enter first fraction: '))

          b = Fraction(input('Enter second fraction: '))
          op = str.lower(
              input('Operation to perform - Add, Subtract, Mulitply, Divide: '))
          if op == 'add':
              add(a, b)
          elif op == 'subtract':
              subtract(a, b)
          elif op == 'multiply':
              multiply(a, b)
          elif op == 'divide':
              divide(a, b)
          else:
              print('Input a valid operation')

          answer = input('Do you want to exit? (y) for yes ')
          if answer == 'y':
              break
#+end_src

* Chapter 2

** Challenge 1 - How Does the Temperature Vary During the Day?

If you enter a search term like “New York weather” in Google’s search engine, you’ll see, among other things, a graph showing the temperature at different times of the present day. Your task here is to re-create such a graph.
Using a city of your choice, find the temperature at different points of the day. Use the data to create two lists in your program and to create a graph with the time of day on the x-axis and the corresponding temperature on the y-axis. The graph should tell you how the temperature varies with the time of day. Try a different city and see how the two cities compare by plotting both lines on the same graph.
The time of day may be indicated by strings such as '10:11 AM' or '09:21 PM'.

#+begin_src python :tangle 2_1.py
  import matplotlib.pyplot as plt

  def plot_forecast():

      time_of_day = ['4 AM', '7 AM', '10 AM', '1 PM', '4 PM', '7PM', '10 PM']
      forecast_temp = [71, 70, 74, 80, 82, 81, 76]
      time_interval = range(1, len(time_of_day) + 1)

      plt.plot(time_interval, forecast_temp, 'o-')
      plt.xticks(time_interval, time_of_day)
      plt.show()

  if __name__ == '__main__':
      plot_forecast()
#+end_src

** Challenge 2 - Exploring a Quadratic Function Visually

In Chapter 1, you learned how to find the roots of a quadratic equation, such as $x^2 + 2x + 1 = 0$. We can turn this equation into a function by writing it as $y = x^2 + 2x + 1$. For any value of $x$, the quadratic function produces some value for $y$. For example, when $x = 1$, $y = 4$. Here’s a program that calculates the value of $y$ for six different values of $x$:

#+begin_src python
  '''
  Quadratic function calculator
  '''

  # Assume values of x
  x_values = [-1, 1, 2, 3, 4, 5]
  for x in x_values:
      # Calculate the value of the quadratic function
      y = x**2 + 2*x + 1
      print('x={0} y={1}'.format(x, y))
#+end_src

At, we create a list with six different values for $x$. The for loop starting at calculates the value of the function above for each of these values and uses the label $y$ to refer to the result. Next, we print the value of $x$ and the corresponding value of $y$. When you run the program, you should see the following output:

#+begin_example
x=-1 y=0
x=1 y=4
x=2 y=9
x=3 y=16
x=4 y=25
x=5 y=36
#+end_example

Notice that the first line of the output is a root of the quadratic equa- tion because it’s a value for x that makes the function equal to 0.
Your programming challenge is to enhance this program to create
a graph of the function. Try using at least 10 values for x instead of the 6 above. Calculate the corresponding y values using the function and then create a graph using these two sets of values.

Once you’ve created the graph, spend some time analyzing how the value of $y$ varies with respect to $x$. Is the variation linear or nonlinear?

#+begin_src python :tangle 2_2.py
import matplotlib.pyplot as plt


def quad_func_calc():
    x_values = [-1, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    y_values = []
    for x in x_values:
        # Calculate the value of quadratic function
        y_values.append(x**2 + x * 2 + 1)
    draw_graph(x_values, y_values)


def draw_graph(x, y):
    plt.plot(x, y, marker='o')
    plt.xlabel('x-axis')

    plt.ylabel('y-axis')
    plt.title('Quadratic Function')


if __name__ == '__main__':
    quad_func_calc()
#+end_src

** Challenge 3 - Enhanced Projectile Trajectory Comparison Program

Your challenge here is to enhance the trajectory comparison program in a few ways. First, your program should print the time of flight, maximum horizontal distance, and maximum vertical distance traveled for each of the velocity and angle of projection combinations.
The other enhancement is to make the program work with any number of initial velocity and angle of projection values, supplied by the user. For example, here’s how the program should ask the user for the inputs:

#+begin_example
How many trajectories? 3
Enter the initial velocity for trajectory 1 (m/s): 45
Enter the angle of projection for trajectory 1 (degrees): 45
Enter the initial velocity for trajectory 2 (m/s): 60
Enter the angle of projection for trajectory 2 (degrees): 45
Enter the initial velocity for trajectory(m/s) 3: 45
Enter the angle of projection for trajectory(degrees) 3: 90
#+end_example

Your program should also ensure that erroneous input is properly handled using a ~try...except~ block, just as in the original program.

#+begin_src python :tangle 2_3.py

  import matplotlib.pyplot as plt
  import math

  g = 9.8

  def draw_graph(x, y):
      plt.plot(x, y)
      plt.xlabel('x-coordinate')
      plt.ylabel('y-coordinate')
      plt.title('Projectile motion at different initial velocities and angles')
    
  def frange(start, final, interval):

      numbers = []
      while start < final:
          numbers.append(start)
          start = start + interval
    
      return numbers

  def draw_trajectory(u, theta, t_flight):
      # list of x and y co-ordinates
      x = []
      y = []
      intervals = frange(0, t_flight, 0.001)
      for t in intervals:
          x.append(u*math.cos(theta)*t)
          y.append(u*math.sin(theta)*t - 0.5*g*t*t)

      #create the graph
      draw_graph(x, y)

  if __name__ == '__main__':

      num_trajectories = int(input('How many trajectories? '))
    
      velocities = []
      angles = []
      for i in range(1, num_trajectories+1):
          v = input('Enter the initial velocity for trajectory {0} (m/s): '.format(i))
          theta = input('Enter the angle of projection for trajectory {0} (degrees): '.format(i))
          velocities.append(float(v))
          angles.append(math.radians(float(theta)))

      for i in range(num_trajectories):
          # calculate time of flight, maximum horizontal distance and
          # maximum vertical distance
          t_flight = 2*velocities[i]*math.sin(angles[i])/g
          S_x = velocities[i]*math.cos(angles[i])*t_flight
          S_y = velocities[i]*math.sin(angles[i])*(t_flight/2) - (1/2)*g*(t_flight/2)**2
          print('Initial velocity: {0} Angle of Projection: {1}'.format(velocities[i], math.degrees(angles[i])))
          print('T: {0} S_x: {1} S_y: {2}'.format(t_flight, S_x, S_y))
          print()
          draw_trajectory(velocities[i], angles[i], t_flight)
        
      # Add a legend and show the graph
      legends = []
      for i in range(0, num_trajectories):
          legends.append('{0} - {1}'.format(velocities[i], math.degrees(angles[i])))
      plt.legend(legends)
      plt.show()
#+end_src

** Challenge 4 - Visualizing Your Expenses

I always find myself asking at the end of the month, “Where did all that money go?” I’m sure this isn’t a problem I alone face.
For this challenge, you’ll write a program that creates a bar chart for easy comparison of weekly expenditures. The program should first ask for the number of categories for the expenditures and the weekly total expen- diture in each category, and then it should create the bar chart showing these expenditures.
Here’s a sample run of how the program should work:

#+begin_example
Enter the number of categories: 4
Enter category: Food
Expenditure: 70
Enter category: Transportation Expenditure: 35
Enter category: Entertainment Expenditure: 30
Enter category: Phone/Internet Expenditure: 30
#+end_example

We haven’t discussed creating a bar chart using matplotlib, so let’s try an example.
A bar chart can be created using matplotlib’s barh() function, which
is also defined in the pyplot module. Figure 2-17 shows a bar chart that illustrates the number of steps I walked during the past week. The days of the week—Sunday, Monday, Tuesday, and so forth—are referred to as the labels. Each horizontal bar starts from the y-axis, and we have to specify the y-coordinate of the center of this position for each of the bars. The length of each bar corresponds to the number of steps specified.
The following program creates the bar chart:

#+begin_src python
  import matplotlib.pyplot as plt

  def create_bar_chart(data, labels):
      # Number of bars
      num_bars = len(data)
      # This list is the point on the y-axis where each
      # Bar is centered. Here it will be [1, 2, 3...]
      positions = range(1, num_bars+1)
      plt.barh(positions, data, align='center')
      # Set the label of each bar
      plt.yticks(positions, labels)
      plt.xlabel('Steps')
      plt.ylabel('Day')
      plt.title('Number of steps walked')
      # Turns on the grid which may assist in visual estimation
      plt.grid()
      plt.show()

  if __name__ == '__main__':
      # Number of steps I walked during the past week
      steps = [6534, 7000, 8900, 10786, 3467, 11045, 5095]
      # Corresponding days
      labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
      create_bar_chart(steps, labels)
#+end_src

The ~create_bar_chart()~ function accepts two parameters—data, which is a list of numbers we want to represent using the bars and labels, and the corresponding labels list. The center of each bar has to be specified, and I’ve arbitrarily chosen the centers as 1, 2, 3, 4, and so on using the help of the ~range()~ function at.
We then call the ~barh()~ function, passing positions and data as the first two arguments and then the keyword argument, align='center', at. The keyword argument specifies that the bars are centered at the positions on the y-axis specified by the list. We then set the labels for each bar, the axis labels, and the title using the ~yticks()~ function. We also call the ~grid()~ function to turn on the grid, which may be useful for a visual estimation of the number of steps. Finally, we call the ~show()~ function.

#+begin_src python :tangle 2_4.py
  import matplotlib.pyplot as plt

  def create_bar_chart(data, labels):
      # number of bars
      num_bars = len(data)
      # this list is the point on the y-axis where each
      # bar is centered. Here it will be [1, 2, 3..]
      positions = range(1, num_bars+1)
      plt.barh(positions, data, align='center')
      # set the label of each bar
      plt.yticks(positions, labels)
      plt.xlabel('Amount')
      plt.ylabel('Categories')
      plt.title('Weekly expenditures')
      # Turns on the grid which may assist in visual estimation
      plt.grid()
      plt.show()

  if __name__ == '__main__':
      n = int(input('Enter the number of categories: '))
      labels = []
      expenditures = []
      for i in range(n):
          category = input('Enter category: ')
          expenditure = float(input('Expenditure: '))
          labels.append(category)
          expenditures.append(expenditure)
      create_bar_chart(expenditures, labels)

#+end_src

** Challenge 5 - Exploring the Relationship Between the Fibonacci Sequence and the Golden Ratio

The Fibonacci sequence (1, 1, 2, 3, 5, . . .) is the series of numbers where the ith number in the series is the sum of the two previous numbers—that is, the numbers in the positions (i − 2) and (i − 1). The successive numbers in this series display an interesting relationship. As you increase the number of terms in the series, the ratios of consecutive pairs of numbers are nearly equal to each other. This value approaches a special number referred to as the golden ratio. Numerically, the golden ratio is the number 1.618033988 . . . , and it’s been the subject of extensive study in music, architecture, and nature. For this challenge, write a program that will plot on a graph the ratio between consecutive Fibonacci numbers for, say, 100 numbers, which will demonstrate that the values approach the golden ratio.
You may find the following function, which returns a list of the first n Fibonacci numbers, useful in implementing your solution:

#+begin_src python
  def fibo(n):
      if n == 1:
          return [1]
      if n == 2:
          return [1, 1] 
      #n> 2
      a= 1
      b= 1
      # First two members of the series 
      series = [a, b]
      for i in range(n):
          c=a+ b 
          series.append(c) 
          a= b
          b= c
      return series
#+end_src
 
#+begin_src python :tangle 2_5.py
  import matplotlib.pyplot as plt

  def fibo(n):
      if n == 1:
          return [1]
      if n == 2:
          return [1, 1]
      # n > 2
      a = 1
      b = 1
      # first two members of the series
      series = [a, b]
      for i in range(n):
          c = a + b
          series.append(c)
          a = b
          b = c

      return series

  def plot_ratio(series):
      ratios = []
      for i in range(len(series)-1):
          ratios.append(series[i+1]/series[i])
      plt.plot(ratios)
      plt.title('Ratio between Fibonacci numbers & Golden ratio')
      plt.ylabel('Ratio')
      plt.xlabel('No.')
      plt.show()

  if __name__ == '__main__':
      # Number of fibonacci numbers
      num = 100
      series = fibo(num)
      plot_ratio(series)

#+end_src
