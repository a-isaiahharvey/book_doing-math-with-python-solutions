<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-11-20 Mon 10:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chapter 6</title>
<meta name="author" content="Allister Isaiah Harvey" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Chapter 6
<br />
<span class="subtitle">Drawing Geometric Shapes and Fractals</span>
</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga2a85d5">1. Challenge 1 - Packing Circles into a Square</a></li>
<li><a href="#org0d8ba3b">2. Challenge 2 - Drawing the Sierpiński Triangle</a></li>
<li><a href="#org5b4f6d9">3. Challenge 3 - Exploring Hénon’s Function</a></li>
<li><a href="#orgc32dcc9">4. Challenge 4 - Drawing the Mandelbrot Set</a>
<ul>
<li><a href="#org5b59bf3">4.1. The imshow() Function</a></li>
<li><a href="#org7da645e">4.2. Creating a List of Lists</a></li>
<li><a href="#org95d7c54">4.3. Drawing the Mandelbrot Set</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-orga2a85d5" class="outline-2">
<h2 id="orga2a85d5"><span class="section-number-2">1.</span> Challenge 1 - Packing Circles into a Square</h2>
<div class="outline-text-2" id="text-1">
<p>
I mentioned earlier that <code>matplotlib</code> supports the creation of other geometric shapes. The <code>Polygon</code> patch is especially interesting, as it allows you to draw polygons with different numbers of sides. Here’s how we can draw a square (each side of length 4):
</p>

<div class="org-src-container">
<pre class="src src-python">'''
Draw a square
'''

from matplotlib import pyplot as plt

def draw_square():
    ax = plt.axes(xlim = (0, 6), ylim = (0, 6))
    square = plt.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)], closed = True)
    ax.add_patch(square)
    plt.show()

if __name__ == '__main__':
    draw_square()
</pre>
</div>

<p>
The <code>Polygon</code> object is created by passing the list of the vertices’ coordi- nates as the first argument. Because we’re drawing a square, we pass the coordinates of the four vertices: (1, 1), (5, 1), (5, 5), and (1, 5). Passing closed=True tells matplotlib that we want to draw a closed polygon, where the starting and the ending vertices are the same.
In this challenge, you’ll attempt a very simplified version of the “circles packed into a square” problem. How many circles of radius 0.5 will fit in the square produced by this code? Draw and find out! Figure 6-11 shows how the final image will look.
The trick here is to start from the lower-left corner of the square— that is, (1, 1)—and then continue adding circles until the entire square is filled. The following snippet shows how you can create the circles and add them to the figure:
</p>

<div class="org-src-container">
<pre class="src src-python">y = 1.5
while y &lt; 5:
    x = 1.5
    while x &lt; 5:
        c = draw_circle(x, y)
        ax.add_patch(c)
        x += 1.0
    y += 1.0
</pre>
</div>

<p>
A point worth noting here is that this is not the most optimal or, for that matter, the only way to pack circles into a square, and finding different ways of solving this problem is popular among mathematics enthusiasts.
</p>

<div class="org-src-container">
<pre class="src src-python">from matplotlib import pyplot as plt

def draw_square():
    square = plt.Polygon([(1, 1), (5, 1), (5, 5), (1, 5)], closed=True)
    return square

def draw_circle(x, y):
    circle = plt.Circle((x, y), radius=0.5, fc='y')
    return circle

if __name__ == '__main__':

    ax = plt.gca()
    s = draw_square()
    ax.add_patch(s)
    y = 1.5
    while y &lt; 5:
        x = 1.5
        while x &lt; 5:
            c = draw_circle(x, y)
            ax.add_patch(c)

            x += 1.0
        y += 1.0

    plt.axis('scaled') 
    plt.show()
</pre>
</div>
</div>
</div>

<div id="outline-container-org0d8ba3b" class="outline-2">
<h2 id="org0d8ba3b"><span class="section-number-2">2.</span> Challenge 2 - Drawing the Sierpiński Triangle</h2>
<div class="outline-text-2" id="text-2">
<p>
The Sierpiński triangle, named after the Polish mathematician Wacław Sierpiński, is a fractal that is an equilateral triangle composed of smaller equilateral triangles embedded inside it. Figure 6-12 shows a Sierpiński triangle composed of 10,000 points.
</p>

<p>
The interesting thing here is that the same process that we used to draw a fern will also draw the Sierpiński triangle—only the transformation rules and their probability will change. Here’s how you can draw the Sierpiński triangle: start with the point (0, 0) and apply one of the follow- ing transformations:
</p>

<p>
<b>Transformation 1:</b>
</p>

<p>
\(x_n+1 = 0.5x_n\)
</p>

<p>
\(y_n+1 = 0.5y_n\)
</p>


<p>
<b>Transformation 2:</b>
</p>

<p>
\(x_n+1 = 0.5x_n + 0.5\)
</p>

<p>
\(y_n+1 = 0.5y_n + 0.5\)
</p>

<p>
<b>Transformation 3:</b>
</p>

<p>
\(x_n+1 = 0.5x_n + 1\)
</p>

<p>
\(y_n+1 = 0.5y_n\)
</p>

<p>
Each of the transformations has an equal probability of being selected—1/3. Your challenge here is to write a program that draws the Sierpiński triangle composed of a certain number of points specified as input.
</p>

<div class="org-src-container">
<pre class="src src-python">import random
import matplotlib.pyplot as plt

def transformation_1(p):
    x = p[0]
    y = p[1]
    x1 = 0.5*x
    y1 = 0.5*y
    return x1, y1

def transformation_2(p):
    x = p[0]
    y = p[1]
    x1 = 0.5*x + 0.5
    y1 = 0.5*y + 0.5
    return x1, y1

def transformation_3(p):
    x = p[0]
    y = p[1]
    x1 = 0.5*x + 1
    y1 = 0.5*y
    return x1, y1

def get_index(probability):
    r = random.random()
    c_probability = 0
    sum_probability = []
    for p in probability:
        c_probability += p
        sum_probability.append(c_probability)
    for item, sp in enumerate(sum_probability):
        if r &lt;= sp:
            return item
    return len(probability)-1

def transform(p):
    # list of transformation functions
    transformations = [transformation_1, transformation_2, transformation_3]
    probability = [1/3, 1/3, 1/3]
    # pick a random transformation function and call it
    tindex = get_index(probability)
    t = transformations[tindex]
    x, y = t(p)
    return x, y

def draw_sierpinski(n):
    # We start with (0, 0)
    x = [0]
    y = [0]

    x1, y1 = 0, 0
    for i in range(n):
       x1, y1 = transform((x1, y1))
       x.append(x1)
       y.append(y1)
    return x, y

if __name__ == '__main__':
    n = int(input('Enter the desired number of points in the Sierpinski Triangle: '))
    x, y = draw_sierpinski(n)
    # Plot the points
    plt.plot(x, y, 'o')
    plt.title('Sierpinski with {0} points'.format(n))
    plt.show()
</pre>
</div>
</div>
</div>

<div id="outline-container-org5b4f6d9" class="outline-2">
<h2 id="org5b4f6d9"><span class="section-number-2">3.</span> Challenge 3 - Exploring Hénon’s Function</h2>
<div class="outline-text-2" id="text-3">
<p>
In 1976, Michel Hénon introduced the Hénon function, which describes a transformation rule for a point \(P(x, y)\) as follows: \(P(x,y) → Q(y + 1 - 1.4x^2, 0.3x)\)
Irrespective of the initial point (provided it’s not very far from the origin), you’ll see that as you create more points, they start lying along curved lines, as shown in Figure 6-13.
Your challenge here is to write a program to create a graph showing 20,000 iterations of this transformation, starting with the point (1, 1).
Extra credit for writing another program to create an animated figure showing the points starting to lie along the curves! See <a href="https://www.youtube.com/watch?v=76ll818RlpQ">https://www.youtube.com/watch?v=76ll818RlpQ</a> for an example.
This is an example of a dynamical system, and the curved lines that all the points seem attracted to are referred to as <i>attractors</i>. To learn more about this function, dynamical systems, and fractals in general, you may want to refer to Fractals: <i>A Very Short Introduction by Kenneth Falconer (Oxford University Press, 2013)</i>.
</p>

<div class="org-src-container">
<pre class="src src-python">import matplotlib.pyplot as plt
from matplotlib import animation

def transform(p):
    x,y  = p
    x1 = y + 1.0 - 1.4*x**2
    y1 = 0.3*x

    return x1, y1

def update_points(i, x, y, plot):
    plot.set_data(x[:i], y[:i])
    return plot,

if __name__ == '__main__':
    p = (0, 0)
    x = [p[0]]
    y = [p[1]]
    for i in range(10000):
        p = transform(p)
        x.append(p[0])
        y.append(p[1])

    fig = plt.gcf()
    ax = plt.axes(xlim = (min(x), max(x)),
                  ylim = (min(y), max(y)))
    plot = plt.plot([], [], 'o')[0]
    anim = animation.FuncAnimation(fig, update_points,
                                   fargs=(x, y, plot),
                                   frames = len(x),
                                   interval = 25)
    plt.title('Henon Function Animation')
    plt.show()

</pre>
</div>
</div>
</div>

<div id="outline-container-orgc32dcc9" class="outline-2">
<h2 id="orgc32dcc9"><span class="section-number-2">4.</span> Challenge 4 - Drawing the Mandelbrot Set</h2>
<div class="outline-text-2" id="text-4">
<p>
Your challenge here is to write a program to draw the <i>Mandelbrot set</i> — another example of the application of simple rules leading to a complicated-looking shape (see Figure 6-14). Before I lay down the steps to do that, however, we’ll first learn about matplotlib’s <code>imshow()</code> function.
</p>
</div>

<div id="outline-container-org5b59bf3" class="outline-3">
<h3 id="org5b59bf3"><span class="section-number-3">4.1.</span> The imshow() Function</h3>
<div class="outline-text-3" id="text-4-1">
<p>
The <code>imshow()</code> function is usually used to display an external image, such as a JPEG or PNG image. You can see an example at <a href="http://matplotlib.org/users/image_tutorial.html">http://matplotlib.org/users/image_tutorial.html</a>. Here, however, we’ll use the function to draw a new image of our own creation via matplotlib.
Consider the part of the Cartesian plane where \(x\) and \(y\) both range from 0 to 5. Now, consider six equidistant points along each axis: (0, 1,
2, 3, 4, 5) along the x-axis and the same set of points along the y-axis. If we take the Cartesian product of these points, we get 36 equally spaced points in the x-y plane with the coordinates (0, 0), (0, 1) . . . (0, 5), (1, 0), (1, 1) . . . (1, 5) . . . (5, 5). Let’s now say that we want to color each of these points with a shade of gray—that is, some of these points will be black, some will be white, and others will be colored with a shade in between, randomly chosen. Figure 6-15 illustrates the scenario.
To create this figure, we have to make a list of six lists. Each of these six lists will in turn consist of six integers ranging from 0 to 10. Each number will correspond to the color for each point, 0 standing for black and 10 standing for white. We’ll then pass this list to the <code>imshow()</code> function along with other necessary arguments.
</p>
</div>
</div>

<div id="outline-container-org7da645e" class="outline-3">
<h3 id="org7da645e"><span class="section-number-3">4.2.</span> Creating a List of Lists</h3>
<div class="outline-text-3" id="text-4-2">
<p>
A list can also contain lists as its members:
</p>

<pre class="example" id="org701b507">
&gt;&gt;&gt; l1 = [1, 2, 3]
&gt;&gt;&gt; l2 = [4, 5, 6]
&gt;&gt;&gt; l = [l1, l2]
</pre>

<p>
Here, we created a list, \(l\), consisting of two lists, \(l1\) and \(l2\). The first element of the list, \(l[0]\), is thus the same as the \(l1\) list and the second element of the list, \(l[1]\), is the same as the \(l2\) list:
</p>

<pre class="example" id="org7505e57">
&gt;&gt;&gt; l[0]
[1, 2, 3]
&gt;&gt;&gt; l[1]
[4, 5, 6]
</pre>

<p>
To refer to an individual element within one of the member lists, we have to specify two indices— \(l[0][1]\) refers to the second element of the first list, \(l[1][2]\) refers to the third element of the second list, and so on.
Now that we know how to work with a list of lists, we can write the program to create a figure similar to Figure 6-15:
</p>

<div class="org-src-container">
<pre class="src src-python">import matplotlib.pyplot as plt
import matplotlib.cm as cm
import random

def initialize_image(x_p, y_p): 
    image = []
    for i in range(y_p):
       x_colors = []
        for j in range(x_p):
            x_colors.append(0)
        image.append(x_colors)
    return image

def color_points():
    x_p = 6
    y_p = 6
    image = initialize_image(x_p, y_p)
    for i in range(y_p):
        for j in range(x_o):
            image[i][j] = random.randint(0, 10)
    plt.imshow(image, origin='lower', extent=(0, 5, 0, 5),
               cmap=cm.Greys_r, interpolation='nearest')
    plt.colorbar()
    plt.show()

if __name__ == '__main__':
    color_points()
</pre>
</div>

<p>
The <code>initialize_image()</code> function at (1) creates a list of lists with each of the elements initialized to 0. It accepts two arguments, <code>x_p</code> and <code>y_p</code>, which correspond to the number of points along the \(x-axis\) and \(y-axis\), respectively. This effectively means that the initialized list image will consist of <code>x_p</code> lists with each list containing <code>y_p</code> zeros.
</p>

<p>
In the <code>color_points()</code> function, once you have the image list back from <code>initialize_image()</code>, assign a random integer between 0 and 10 to the element <code>image[i][j]</code> at (2). When we assign this random integer to the element, we are assigning a color to the point in the Cartesian plane that’s i steps along the \(y-axis\) and <i>j</i> steps along the \(x-axis\) from the origin. It’s important to note that the <code>imshow()</code> function automatically deduces the color of a point from its position in the image list and doesn’t care about its specific <i>x</i>- and <i>y</i>-coordinates.
</p>

<p>
Then, call the <code>imshow()</code> function at (3), passing image as the first argument. The keyword argument <code>origin='lower'</code> specifies that the number in <code>image[0][0]</code> corresponds to the color of the point (0, 0). The keyword argument <code>extent=(0, 5, 0, 5)</code> sets the lower-left and upper-right corners of the image to (0, 0) and (5, 5), respectively. The keyword argument <code>cmap=cm.Greys_r</code> specifies that we’re going to create a grayscale image.
</p>

<p>
The last keyword argument, <code>interpolation='nearest'</code>, specifies that matplotlib should color a point for which the color wasn’t specified with the same color as the one nearest to it. What does this mean? Note that we consider and specify the color for only 36 points in the region (0, 5) and (5, 5). Because there is an infinite number of points in this region, we tell matplotlib to set the color of an unspecified point to that of its nearest point. This is the reason you see color “boxes” around each point in the figure.
</p>

<p>
Call the <code>colorbar()</code> function to display a color bar in the figure showing which integer corresponds to which color. Finally, call <code>show()</code> to display the image. Note that due to the use of the <code>random.randint()</code> function, your image will be colored differently than the one in Figure 6-15.
</p>

<p>
If you increase the number of points along each axis by setting <code>x_p</code> and <code>y_p</code> to, let’s say, 20 in <code>color_points()</code>, you’ll see a figure similar to the one shown in Figure 6-16. Note that the color boxes grow smaller in size. If you increase the number of points even more, you’ll see the size of the boxes shrink further, giving the illusion that each point has a different color.
</p>
</div>
</div>

<div id="outline-container-org95d7c54" class="outline-3">
<h3 id="org95d7c54"><span class="section-number-3">4.3.</span> Drawing the Mandelbrot Set</h3>
<div class="outline-text-3" id="text-4-3">
<p>
We’ll consider the area of the \(x-y\) plane between (−2.5, −1.0) and (1.0, 1.0) and divide each axis into 400 equally spaced points. The Cartesian product of these points will give us 1,600 equally spaced points in this region. We’ll refer to these points as \((x_1, y_1), (x_1, y_2) . . . (x_400, y_400)\).
Create a list, <code>image</code>, by calling the <code>initialize_image()</code> function we saw earlier with both <code>x_p</code> and <code>y_p</code> set to 400. Then, follow these steps for each of the generated points \((x_i, y_k)\):
</p>

<ol class="org-ol">
<li>First, create two complex numbers, \(z_1 = 0 + 0j\) and \(c = x_i + y_{k}j\). (Recall that we use <i>j</i> for \(\sqrt{-1}\))</li>
<li>Create a label iteration and set it to 0—that is, <code>iteration=0</code>.</li>
<li>Create a complex number, \(z_1 = z_{1}^{2} + c\).</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Allister Isaiah Harvey</p>
<p class="date">Created: 2023-11-20 Mon 10:53</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>